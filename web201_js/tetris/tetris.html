<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
     #canvas {
            border: solid deepskyblue 10px;
    }

    #score, #scoreLabel{
        font-weight: bolder;
        font-size: 40px;
    }

    #canvas, #score {
        vertical-align: top;
    }
  </style>
</head>

<body>
    <canvas id="canvas" width="300" height="600"></canvas>
    <label id="scoreLabel" for="score">Score: </label>
    <span id="score">0</span>
  
    <script src="patterns.js"></script>
    <script>
    var canvas = document.querySelector('canvas');
    var ctx = canvas.getContext('2d');

    // events
    let pause = false;
    window.addEventListener('keydown', function (e) {
      if (e.code === 'ArrowLeft') {
        currTetromino.moveLeft();
      } else if (e.code === 'ArrowRight') {
        currTetromino.moveRight();
      } else if (e.code === 'ArrowDown') {
        currTetromino.moveDown();
      } else if (e.code==='ArrowUp') {
        currTetromino.rotate();
      }else if (e.code === 'KeyP') {
        pause = !pause;
      }
    });

    // square
    square = {
      size: 30,
      color: 'white',
      strokeColor: 'black',
      draw: function (row, col) {
        // row/col -> x/y
        let x = col * 30;
        let y = row * 30;
        // draw
        ctx.beginPath();
        ctx.rect(x, y, this.size, this.size);
        ctx.strokeStyle = this.strokeColor;
        ctx.stroke();
        ctx.fillStyle = this.color;
        ctx.fill();
      }
    }
    square.draw(1, 0);

    // board
    board = {
      rows:20,
      cols:10,
      squares: (function() {
        let squares=[];
        for (let r=0; r<20; r++) {
          let row=[];
          for (let c=0; c<10; c++) {
            let s={...square};
            row.push(s);
          }
          squares.push(row);
        }
        return squares;
      })(),
      draw: function() {
        for (let r=0; r<20; r++){
          for (let c=0; c<10; c++) {
            this.squares[r][c].draw(r,c);
          }
        }
      }
    }
    board.draw();

    Tetromino=function(aShape,row,col) {
      let shape=aShape;
      let currInd=0;
      let currPattern=shape.patterns[currInd];

      function draw() {
        for (let r=0; r<shape.size; r++) {
          for (let c=0; c<shape.size; c++) {
            // draw border
            let b={...square};
            b.size=square.size*shape.size;
            b.color='transparent';
            b.strokeColor='red';
            b.draw(row,col);

            // convert tr,tc,r,c -> x,y
            if (currPattern[r][c]!=0) {
              let s={...square};
              s.color=shape.color;
              s.draw(row+r,col+c);
            }
          }
        }
      }

      function update() {
        row++;
      }

      function rotate() {
        currInd++;
        if (currInd==shape.patterns.length) {
          currInd=0;
        }
        currPattern=shape.patterns[currInd];
        // draw
        ctx.clearRect(0,0,canvas.width,canvas.height);
        board.draw();
        draw();
      }

      function inBoundary(tetrominoRow, tetrominoCol) {
        for (let r=0; r<shape.size; r++) {
          for (let c=0; c<shape.size; c++) {
            // r,c: relative row/col for square in tetromino
            // rr,cc: absolute row/col for square in board
            let rr=(tetrominoRow!=undefined?tetrominoRow:row)+r;
            let cc=(tetrominoCol!=undefined?tetrominoCol:col)+c;
            if ((cc<0 || cc>9 || rr>19) && currPattern[r][c]!=0) {
              console.log('out of boundary');
              return false;
            }
          }
        }
        return true;
      }

      function stamp() {
        for (let r=0; r<shape.size; r++) {
            for (let c=0; c<shape.size; c++) {
                let rr=row+r;
                let cc=col+c;
                if(currPattern[r][c]!=0){
                    board.squares[rr][cc].color=shape.color;
                }
            }
        }
      }

      return {
        getRow:function(){
            return row;
        },
        getCol:function(){
            return col;
        },
        shape:shape,
        draw:draw,
        update:update,
        rotate:rotate,
        moveLeft: function() {
            if(inBoundary(undefined, col-1)) {
                col--;
                ctx.clearRect(0,0,canvas.width,canvas.height);
                board.draw();
                draw();
            }
        },
        moveRight: function() {
            if(inBoundary(undefined, col+1)) {
                col++;
                ctx.clearRect(0,0,canvas.width,canvas.height);
                board.draw();
                draw();
            }
        },
        moveDown: function() {
            if(inBoundary(row+1, undefined)) {
                row++;
                ctx.clearRect(0,0,canvas.width,canvas.height);
                board.draw();
                draw();
            } else {
                stamp();
            }
        },
        inBoundary:inBoundary,
        stamp:stamp
      }
    }

    // test
    currTetromino = Tetromino(Z, 0, 0);
    // currTetromino.draw();

    //
    let pre = null;
    function loop() {
      requestAnimationFrame(loop);
      if (pause) return;

      // set interval to 1 sec
      let curr = Date.now();
      if (curr - pre < 1000) return;
      pre = curr;

      // 1 clear
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // 2 draw
      board.draw();
      currTetromino.draw();

      // 3 update
      // currTetromino.update();
    }
    loop();
  </script>

</body>

</html>